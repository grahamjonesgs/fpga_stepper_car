#include <stdio.h>
#include <unistd.h>
#include "pigpiod_if2.h"

#define MESSAGE_TRIES 10

#define START_MSG_CODE 0x10
#define CRC_ERROR_CODE 0x02
#define TIMEOUT_CODE 0x03
#define ACK_OK 0x01

#define MSG_TYPE_MOTOR 0x01
#define MSG_TYPE_ENABLE 0x02
#define MSG_TYPE_LED 0x03
#define MSG_TYPE_STATUS 0x04;

#define LEFT_BACKWARDS 0x01
#define RIGHT_BACKWARDS 0x02
#define COUNT_STEPS 0x04
#define COUNT_RIGHT 0x08

/*
 8 byte car comtrol message
    Byte 0: Message type, 
        0x01 - Motor control
        0x02 - Enable control
        0x03 - LED control
        0x04 - Status Request
        
 Motor Control
   Byte 1 - directions (bytes 8-15)
        bit 0 - left dir
        bit 1 - right dir
        bit 2 - mode, 0 for ever, 1 count
        bit 3 - 0 count left, 1 count right
   Byte 2 - Left speed (bytes 16-23)
   Btye 3 - Right speed (bytes 24-31)
   Byte 4/5/6 - Max number of step  (bytes 32-55)
   
   Enable Control
   Byte 1, bit 0 - enable
   
   LED control
   Byte 0 Red
   Byte 1 Blue
   Byte 2 Green
   
   
   Modes LSN
   X0 Off
   X1 On
   X2 Flash
   X3 Pulse
   Speed MSN // only for flash and pulse
   0x0X Pulse Slow
   0x1X Pulse Medium
   0x2X Pulse Fast
   
   
   
 */ 

int pi;
int spi_handle;

int message_send(char* msg_buf)
{
        char full_msg[255];
        int counter;
        char ret_code;

        full_msg[0]=START_MSG_CODE; // Start msg char
        for (int i=0; i<8; i++) {
                full_msg[i+1]=msg_buf[i];
        }

        counter=0;
        for (int i=1; i<=8; i++)
        {
                counter=counter+full_msg[i];
        }

        full_msg[9]=counter%256; // set CRC value

        for (int i=0; i<MESSAGE_TRIES; i++)
        {
                spi_write(pi, spi_handle, full_msg, 10);
                spi_read(pi, spi_handle, &ret_code,1);
                switch (ret_code) {
                case ACK_OK:
                        printf("Message sent OK\n");
                        return(0);
                        break;
                case CRC_ERROR_CODE:
                        printf("Message CRC error\n");
                        break;
                case TIMEOUT_CODE:
                        printf("Message timeout error\n");
                        break;
                case 0:
                        printf("Message NULL return\n");
                        break;
                default:
                        printf("Message unknown code return\n");

                }
        }
        return(1);
}

int enable_motor(int flag) {
        char msg[255];

        msg[0]=MSG_TYPE_ENABLE;
        msg[1]=flag;
        return(message_send(msg));
}

int read_version_message(void) {
        char r_msg[255];
        char msg;

        msg=0x21; // Request message flag
        spi_write(pi, spi_handle, &msg, 1); // Request
        spi_read(pi,spi_handle,r_msg,8);

        printf("Version message %02X %02X %02X %02X %02X %02X %02X %02X\n",r_msg[7],r_msg[6],r_msg[5],r_msg[4],r_msg[3],r_msg[2],r_msg[1],r_msg[0]);
        printf("Version is %i.%i%i\n",r_msg[2]&0x08,r_msg[1],r_msg[0]);

}

int read_motor_message(void) {
        char r_msg[255];
        char msg;

        msg=0x22; // Request message flag
        spi_write(pi, spi_handle, &msg, 1); // Request
        spi_read(pi,spi_handle,r_msg,8);

        printf("Motor message %02X %02X %02X %02X %02X %02X %02X %02X\n",r_msg[7],r_msg[6],r_msg[5],r_msg[4],r_msg[3],r_msg[2],r_msg[1],r_msg[0]);

}

int read_null_message(void) {
        char r_msg[255];
        char msg;

        msg=0x20; // Request message flag
        spi_write(pi, spi_handle, &msg, 1); // Request
        spi_read(pi,spi_handle,r_msg,8);

        printf("Null message %02X %02X %02X %02X %02X %02X %02X %02X\n",r_msg[7],r_msg[6],r_msg[5],r_msg[4],r_msg[3],r_msg[2],r_msg[1],r_msg[0]);

}


int set_motor (char left_speed, char right_speed, int left_dir, int right_dir) {
        char msg[255];

        if (left_dir>1) left_dir=1;
        if (right_dir>1) right_dir=1;

        msg[0]=MSG_TYPE_MOTOR;
        msg[1]=left_dir*LEFT_BACKWARDS|right_dir*RIGHT_BACKWARDS;
        msg[2]=left_speed;
        msg[3]=right_speed;
        return(message_send(msg));

}


int send_led (char red, char blue, char green) {
        char msg[255];

        msg[0]=MSG_TYPE_LED;
        msg[1]=red;
        msg[2]=blue;
        msg[3]=green;
        msg[4]=0;
        msg[5]=0;
        msg[6]=0;
        msg[7]=0;
        return(message_send(msg));

}

int set_motor_limit (char left_speed, char right_speed, int left_dir, int right_dir, int steps, int count_right) {
        char msg[255];

        if (left_dir>1) left_dir=1;
        if (right_dir>1) right_dir=1;
        if (count_right>1) count_right=1;

        msg[0]=MSG_TYPE_MOTOR;
        msg[1]=left_dir*LEFT_BACKWARDS|right_dir*RIGHT_BACKWARDS|COUNT_STEPS|count_right*COUNT_RIGHT;
        msg[2]=left_speed;
        msg[3]=right_speed;
        msg[4]=steps%256;
        msg[5]=(steps/256)%256;
        msg[6]=steps/(256*256);
        return(message_send(msg));

}

int main (int argc, char **argv)
{

        char buf[255];

        pi=pigpio_start(NULL,NULL);
        if (pi<0) {
                printf("gpio init failed\n");
                return 1;
        }
        else {
                printf("gpio init ok\n");

        }

        spi_handle=spi_open(pi, 0, 1e7, 0);

        enable_motor(0);
        

        //set_motor (0x0,0x0,0,1);
        set_motor_limit (10,10,1,1, 10*200, 0);
        //set_motor (10,10,1,1);
        
        //sleep(5);
        //set_motor (0x0,0x0,0,1);
        
        //enable_motor(1);


        read_motor_message();
        read_version_message();

        //send_led(0x03,0x13,0x23);
        

        spi_close(pi,spi_handle);








}
